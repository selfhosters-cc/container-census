package vulnerability

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

// Scanner handles vulnerability scanning using Trivy
type Scanner struct {
	config    *Config
	cache     *Cache
	storage   VulnerabilityStorage
	trivyLock sync.Mutex // Serialize Trivy DB access to prevent locks
}

// NewScanner creates a new vulnerability scanner
func NewScanner(config *Config, storage VulnerabilityStorage) *Scanner {
	cache := NewCache(storage, config.GetCacheTTL())
	return &Scanner{
		config:  config,
		cache:   cache,
		storage: storage,
	}
}

// ScanImage scans an image for vulnerabilities using Trivy
// imageID should be the SHA256 image ID, imageName should be the image reference
func (s *Scanner) ScanImage(ctx context.Context, imageID string, imageName string) (*VulnerabilityScanResult, error) {
	if !s.config.GetEnabled() {
		return nil, fmt.Errorf("vulnerability scanning is disabled")
	}

	startTime := time.Now()
	log.Printf("Starting vulnerability scan for image: %s (ID: %s)", imageName, imageID)

	// Create context with timeout
	scanCtx, cancel := context.WithTimeout(ctx, s.config.GetScanTimeout())
	defer cancel()

	// Run Trivy scan using the image name
	trivyResult, err := s.runTrivy(scanCtx, imageName)
	if err != nil {
		scanDuration := time.Since(startTime).Milliseconds()
		// Save failed scan with the actual image ID
		failedScan := &VulnerabilityScan{
			ImageID:        imageID,
			ImageName:      imageName,
			ScannedAt:      time.Now(),
			ScanDurationMs: scanDuration,
			Success:        false,
			Error:          err.Error(),
		}
		_ = s.storage.SaveVulnerabilityScan(failedScan, nil)
		return nil, fmt.Errorf("trivy scan failed: %w", err)
	}

	// Parse results
	vulnerabilities := s.parseTrivyResult(trivyResult, imageID)
	severityCounts := CalculateSeverityCounts(vulnerabilities)
	scanDuration := time.Since(startTime).Milliseconds()

	// Create scan record with the actual image ID
	scan := &VulnerabilityScan{
		ImageID:              imageID,
		ImageName:            imageName,
		ScannedAt:            time.Now(),
		ScanDurationMs:       scanDuration,
		Success:              true,
		TrivyDBVersion:       getTrivyDBVersion(),
		TotalVulnerabilities: severityCounts.GetTotal(),
		SeverityCounts:       severityCounts,
	}

	// Save to cache and database
	err = s.cache.Set(scan, vulnerabilities)
	if err != nil {
		log.Printf("Warning: Failed to cache scan results: %v", err)
	}

	log.Printf("Vulnerability scan completed for %s: %d vulnerabilities found (%d critical, %d high) in %dms",
		imageName, severityCounts.GetTotal(), severityCounts.Critical, severityCounts.High, scanDuration)

	return &VulnerabilityScanResult{
		Scan:            *scan,
		Vulnerabilities: vulnerabilities,
	}, nil
}

// runTrivy executes the Trivy CLI and returns the results
func (s *Scanner) runTrivy(ctx context.Context, imageRef string) (*TrivyResult, error) {
	// Serialize Trivy DB access to prevent "database in use" errors
	// Multiple workers can't access Trivy's vulnerability DB simultaneously
	s.trivyLock.Lock()
	defer s.trivyLock.Unlock()

	// Build Trivy command
	args := []string{
		"image",
		"--format", "json",
		"--quiet",
		"--no-progress",
	}

	// Only skip DB updates if the database exists
	// This prevents "cannot specify --skip-db-update on first run" errors
	cacheDir := s.config.GetCacheDir()
	dbPath := filepath.Join(cacheDir, "db", "trivy.db")
	if _, err := os.Stat(dbPath); err == nil {
		args = append(args, "--skip-db-update", "--skip-java-db-update")
	}

	args = append(args,
		"--image-src", "docker", // Only scan from local Docker daemon
		"--cache-dir", cacheDir,
		imageRef,
	)

	cmd := exec.CommandContext(ctx, "trivy", args...)

	// Capture stdout only (ignore stderr to reduce noise from expected errors)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err := cmd.Run()
	if err != nil {
		// Check if trivy is installed
		if strings.Contains(err.Error(), "executable file not found") {
			return nil, fmt.Errorf("trivy not found in PATH - please install trivy")
		}
		// Only include stderr in error for unexpected failures (not image-not-found or rate-limit)
		stderrStr := stderr.String()

		if strings.Contains(stderrStr, "unable to find the specified image") ||
			strings.Contains(stderrStr, "TOOMANYREQUESTS") ||
			strings.Contains(stderrStr, "No such image") {
			// These are expected errors - return simple message
			return nil, fmt.Errorf("image not available for scanning")
		}
		return nil, fmt.Errorf("trivy command failed: %w (stderr: %s)", err, stderrStr)
	}

	output := stdout.Bytes()

	// Parse JSON output
	var result TrivyResult
	err = json.Unmarshal(output, &result)
	if err != nil {
		return nil, fmt.Errorf("failed to parse trivy output: %w", err)
	}

	return &result, nil
}

// parseTrivyResult converts Trivy output to our vulnerability format
func (s *Scanner) parseTrivyResult(trivyResult *TrivyResult, imageID string) []Vulnerability {
	vulnerabilities := make([]Vulnerability, 0)

	for _, result := range trivyResult.Results {
		if result.Vulnerabilities == nil {
			continue
		}

		for _, tv := range result.Vulnerabilities {
			vuln := Vulnerability{
				ImageID:           imageID,
				VulnerabilityID:   tv.VulnerabilityID,
				PkgName:           tv.PkgName,
				InstalledVersion:  tv.InstalledVersion,
				FixedVersion:      tv.FixedVersion,
				Severity:          strings.ToUpper(tv.Severity),
				Title:             tv.Title,
				Description:       tv.Description,
				PublishedDate:     tv.PublishedDate,
				LastModifiedDate:  tv.LastModifiedDate,
				PrimaryURL:        tv.PrimaryURL,
			}
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}

	return vulnerabilities
}

// GetCachedScan retrieves a cached scan if available
func (s *Scanner) GetCachedScan(imageID string) (*VulnerabilityScan, error) {
	return s.cache.Get(imageID)
}

// NeedsScan checks if an image needs to be scanned
func (s *Scanner) NeedsScan(imageID string) bool {
	return s.cache.NeedsScan(imageID)
}

// InvalidateCache removes a scan from the cache
func (s *Scanner) InvalidateCache(imageID string) {
	s.cache.Invalidate(imageID)
}

// UpdateTrivyDB updates the Trivy vulnerability database
func (s *Scanner) UpdateTrivyDB(ctx context.Context) error {
	log.Println("Updating Trivy vulnerability database...")

	cmd := exec.CommandContext(ctx, "trivy", "image", "--download-db-only", "--cache-dir", s.config.GetCacheDir())
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to update trivy database: %w (output: %s)", err, string(output))
	}

	log.Println("Trivy database updated successfully")
	return nil
}

// GetConfig returns the scanner configuration
func (s *Scanner) GetConfig() *Config {
	return s.config
}

// SetConfig updates the scanner configuration
func (s *Scanner) SetConfig(config *Config) {
	s.config = config
	s.cache.SetTTL(config.GetCacheTTL())
}

// extractImageID extracts the image ID from an image reference
// For now, use the image reference as the ID (we'll get the actual SHA from Docker later)
func extractImageID(imageRef string) string {
	// Remove registry prefix if present
	parts := strings.Split(imageRef, "/")
	if len(parts) > 1 {
		imageRef = parts[len(parts)-1]
	}
	return imageRef
}

// getTrivyDBVersion attempts to get the Trivy DB version
func getTrivyDBVersion() string {
	cmd := exec.Command("trivy", "--version")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return "unknown"
	}

	// Parse version from output (e.g., "Version: 0.47.0")
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "Version:") {
			return strings.TrimSpace(strings.TrimPrefix(line, "Version:"))
		}
	}

	return "unknown"
}
