package vulnerability

import (
	"fmt"
	"os"
	"sync"
	"time"
)

// Config holds the vulnerability scanner configuration
type Config struct {
	mu                     sync.RWMutex
	Enabled                bool          `json:"enabled"`
	AutoScanNewImages      bool          `json:"auto_scan_new_images"`
	WorkerPoolSize         int           `json:"worker_pool_size"`
	ScanTimeoutMinutes     int           `json:"scan_timeout_minutes"`
	CacheTTLHours          int           `json:"cache_ttl_hours"`
	RescanIntervalHours    int           `json:"rescan_interval_hours"`
	CacheDir               string        `json:"cache_dir"`
	DBUpdateIntervalHours  int           `json:"db_update_interval_hours"`
	RetentionDays          int           `json:"retention_days"`
	DetailedRetentionDays  int           `json:"detailed_retention_days"`
	AlertOnCritical        bool          `json:"alert_on_critical"`
	AlertOnHigh            bool          `json:"alert_on_high"`
	MaxQueueSize           int           `json:"max_queue_size"`
}

// DefaultConfig returns the default vulnerability scanner configuration
func DefaultConfig() *Config {
	// Allow cache directory to be overridden via environment variable
	cacheDir := "/app/data/.trivy"
	if envCacheDir := os.Getenv("TRIVY_CACHE_DIR"); envCacheDir != "" {
		cacheDir = envCacheDir
	}

	return &Config{
		Enabled:                true,
		AutoScanNewImages:      true,
		WorkerPoolSize:         5,
		ScanTimeoutMinutes:     10,
		CacheTTLHours:          24,
		RescanIntervalHours:    168, // 7 days
		CacheDir:               cacheDir,
		DBUpdateIntervalHours:  24,
		RetentionDays:          90,
		DetailedRetentionDays:  30,
		AlertOnCritical:        true,
		AlertOnHigh:            false,
		MaxQueueSize:           100,
	}
}

// GetEnabled returns whether vulnerability scanning is enabled
func (c *Config) GetEnabled() bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.Enabled
}

// SetEnabled sets whether vulnerability scanning is enabled
func (c *Config) SetEnabled(enabled bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.Enabled = enabled
}

// GetAutoScanNewImages returns whether new images should be automatically scanned
func (c *Config) GetAutoScanNewImages() bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.AutoScanNewImages
}

// SetAutoScanNewImages sets whether new images should be automatically scanned
func (c *Config) SetAutoScanNewImages(autoScan bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.AutoScanNewImages = autoScan
}

// GetWorkerPoolSize returns the number of concurrent scan workers
func (c *Config) GetWorkerPoolSize() int {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.WorkerPoolSize
}

// SetWorkerPoolSize sets the number of concurrent scan workers
func (c *Config) SetWorkerPoolSize(size int) error {
	if size < 1 || size > 10 {
		return fmt.Errorf("worker pool size must be between 1 and 10")
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	c.WorkerPoolSize = size
	return nil
}

// GetScanTimeout returns the scan timeout duration
func (c *Config) GetScanTimeout() time.Duration {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return time.Duration(c.ScanTimeoutMinutes) * time.Minute
}

// SetScanTimeout sets the scan timeout in minutes
func (c *Config) SetScanTimeout(minutes int) error {
	if minutes < 1 || minutes > 60 {
		return fmt.Errorf("scan timeout must be between 1 and 60 minutes")
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	c.ScanTimeoutMinutes = minutes
	return nil
}

// GetCacheTTL returns the cache TTL duration
func (c *Config) GetCacheTTL() time.Duration {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return time.Duration(c.CacheTTLHours) * time.Hour
}

// SetCacheTTL sets the cache TTL in hours
func (c *Config) SetCacheTTL(hours int) error {
	if hours < 1 || hours > 168 {
		return fmt.Errorf("cache TTL must be between 1 and 168 hours")
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	c.CacheTTLHours = hours
	return nil
}

// GetRescanInterval returns the rescan interval duration
func (c *Config) GetRescanInterval() time.Duration {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return time.Duration(c.RescanIntervalHours) * time.Hour
}

// SetRescanInterval sets the rescan interval in hours
func (c *Config) SetRescanInterval(hours int) error {
	if hours < 24 || hours > 720 {
		return fmt.Errorf("rescan interval must be between 24 and 720 hours")
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	c.RescanIntervalHours = hours
	return nil
}

// GetCacheDir returns the cache directory path
func (c *Config) GetCacheDir() string {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.CacheDir
}

// SetCacheDir sets the cache directory path
func (c *Config) SetCacheDir(dir string) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.CacheDir = dir
}

// GetDBUpdateInterval returns the database update interval duration
func (c *Config) GetDBUpdateInterval() time.Duration {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return time.Duration(c.DBUpdateIntervalHours) * time.Hour
}

// GetAlertOnCritical returns whether to alert on critical vulnerabilities
func (c *Config) GetAlertOnCritical() bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.AlertOnCritical
}

// SetAlertOnCritical sets whether to alert on critical vulnerabilities
func (c *Config) SetAlertOnCritical(alert bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.AlertOnCritical = alert
}

// GetAlertOnHigh returns whether to alert on high vulnerabilities
func (c *Config) GetAlertOnHigh() bool {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.AlertOnHigh
}

// SetAlertOnHigh sets whether to alert on high vulnerabilities
func (c *Config) SetAlertOnHigh(alert bool) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.AlertOnHigh = alert
}

// GetMaxQueueSize returns the maximum queue size
func (c *Config) GetMaxQueueSize() int {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.MaxQueueSize
}

// GetRetentionDays returns the retention days for vulnerability scans
func (c *Config) GetRetentionDays() int {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.RetentionDays
}

// GetDetailedRetentionDays returns the detailed retention days for vulnerability data
func (c *Config) GetDetailedRetentionDays() int {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.DetailedRetentionDays
}

// Clone creates a copy of the configuration
func (c *Config) Clone() *Config {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return &Config{
		Enabled:                c.Enabled,
		AutoScanNewImages:      c.AutoScanNewImages,
		WorkerPoolSize:         c.WorkerPoolSize,
		ScanTimeoutMinutes:     c.ScanTimeoutMinutes,
		CacheTTLHours:          c.CacheTTLHours,
		RescanIntervalHours:    c.RescanIntervalHours,
		CacheDir:               c.CacheDir,
		DBUpdateIntervalHours:  c.DBUpdateIntervalHours,
		RetentionDays:          c.RetentionDays,
		DetailedRetentionDays:  c.DetailedRetentionDays,
		AlertOnCritical:        c.AlertOnCritical,
		AlertOnHigh:            c.AlertOnHigh,
		MaxQueueSize:           c.MaxQueueSize,
	}
}

// Update updates the configuration with new values
func (c *Config) Update(newConfig *Config) error {
	// Validate before updating
	if newConfig.WorkerPoolSize < 1 || newConfig.WorkerPoolSize > 10 {
		return fmt.Errorf("worker pool size must be between 1 and 10")
	}
	if newConfig.ScanTimeoutMinutes < 1 || newConfig.ScanTimeoutMinutes > 60 {
		return fmt.Errorf("scan timeout must be between 1 and 60 minutes")
	}
	if newConfig.CacheTTLHours < 1 || newConfig.CacheTTLHours > 168 {
		return fmt.Errorf("cache TTL must be between 1 and 168 hours")
	}
	if newConfig.RescanIntervalHours < 24 || newConfig.RescanIntervalHours > 720 {
		return fmt.Errorf("rescan interval must be between 24 and 720 hours")
	}

	c.mu.Lock()
	defer c.mu.Unlock()

	c.Enabled = newConfig.Enabled
	c.AutoScanNewImages = newConfig.AutoScanNewImages
	c.WorkerPoolSize = newConfig.WorkerPoolSize
	c.ScanTimeoutMinutes = newConfig.ScanTimeoutMinutes
	c.CacheTTLHours = newConfig.CacheTTLHours
	c.RescanIntervalHours = newConfig.RescanIntervalHours
	c.CacheDir = newConfig.CacheDir
	c.DBUpdateIntervalHours = newConfig.DBUpdateIntervalHours
	c.RetentionDays = newConfig.RetentionDays
	c.DetailedRetentionDays = newConfig.DetailedRetentionDays
	c.AlertOnCritical = newConfig.AlertOnCritical
	c.AlertOnHigh = newConfig.AlertOnHigh
	c.MaxQueueSize = newConfig.MaxQueueSize

	return nil
}
