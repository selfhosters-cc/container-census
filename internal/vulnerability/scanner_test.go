package vulnerability

import (
	"context"
	"fmt"
	"testing"
	"time"
)

func TestScanner_NeedsScan(t *testing.T) {
	storage := newMockStorage()
	config := DefaultConfig()
	config.SetCacheTTL(24) // 24 hours

	scanner := NewScanner(config, storage)

	// Image with no scan should need scanning
	if !scanner.NeedsScan("sha256:new-image") {
		t.Error("Expected NeedsScan to return true for new image")
	}

	// Save a fresh scan
	scan := &VulnerabilityScan{
		ImageID:   "sha256:fresh-image",
		ImageName: "nginx:latest",
		ScannedAt: time.Now(),
		Success:   true,
	}
	vulnerabilities := []Vulnerability{}

	err := storage.SaveVulnerabilityScan(scan, vulnerabilities)
	if err != nil {
		t.Fatalf("Failed to save scan: %v", err)
	}

	// Image with fresh scan should NOT need scanning
	if scanner.NeedsScan("sha256:fresh-image") {
		t.Error("Expected NeedsScan to return false for fresh scan")
	}

	// Save a stale scan (25 hours old, beyond 24h TTL)
	staleScan := &VulnerabilityScan{
		ImageID:   "sha256:stale-image",
		ImageName: "redis:latest",
		ScannedAt: time.Now().Add(-25 * time.Hour),
		Success:   true,
	}

	err = storage.SaveVulnerabilityScan(staleScan, vulnerabilities)
	if err != nil {
		t.Fatalf("Failed to save stale scan: %v", err)
	}

	// Image with stale scan should need scanning
	if !scanner.NeedsScan("sha256:stale-image") {
		t.Error("Expected NeedsScan to return true for stale scan")
	}
}

func TestScanner_GetCachedScan(t *testing.T) {
	storage := newMockStorage()
	config := DefaultConfig()
	config.SetCacheTTL(24)

	scanner := NewScanner(config, storage)

	// Save a scan
	scan := &VulnerabilityScan{
		ImageID:              "sha256:abc123",
		ImageName:            "nginx:latest",
		ScannedAt:            time.Now(),
		Success:              true,
		TotalVulnerabilities: 5,
	}
	vulnerabilities := []Vulnerability{
		{
			ImageID:         "sha256:abc123",
			VulnerabilityID: "CVE-2024-0001",
			Severity:        "HIGH",
			PkgName:         "openssl",
		},
	}

	err := storage.SaveVulnerabilityScan(scan, vulnerabilities)
	if err != nil {
		t.Fatalf("Failed to save scan: %v", err)
	}

	// Retrieve cached scan
	cached, err := scanner.GetCachedScan("sha256:abc123")
	if err != nil {
		t.Fatalf("Failed to get cached scan: %v", err)
	}

	if cached == nil {
		t.Fatal("Expected cached scan, got nil")
	}

	if cached.ImageID != "sha256:abc123" {
		t.Errorf("Expected image ID sha256:abc123, got %s", cached.ImageID)
	}

	if cached.TotalVulnerabilities != 5 {
		t.Errorf("Expected 5 vulnerabilities, got %d", cached.TotalVulnerabilities)
	}
}

func TestScanner_InvalidateCache(t *testing.T) {
	storage := newMockStorage()
	config := DefaultConfig()
	config.SetCacheTTL(24)

	scanner := NewScanner(config, storage)

	// Save a scan
	scan := &VulnerabilityScan{
		ImageID:   "sha256:abc123",
		ImageName: "nginx:latest",
		ScannedAt: time.Now(),
		Success:   true,
	}
	err := storage.SaveVulnerabilityScan(scan, []Vulnerability{})
	if err != nil {
		t.Fatalf("Failed to save scan: %v", err)
	}

	// Should NOT need scanning (fresh scan)
	if scanner.NeedsScan("sha256:abc123") {
		t.Error("Expected NeedsScan to return false before invalidation")
	}

	// Invalidate cache
	scanner.InvalidateCache("sha256:abc123")

	// Now should need scanning (cache invalidated, will load from DB and see it's fresh)
	// Actually, invalidation only clears memory cache, DB still has fresh scan
	// So let's verify the cache was cleared from memory
	cacheSize := scanner.cache.Size()
	if cacheSize != 0 {
		t.Errorf("Expected cache size 0 after invalidation, got %d", cacheSize)
	}
}

func TestScanner_SetConfig(t *testing.T) {
	storage := newMockStorage()
	config1 := DefaultConfig()
	config1.SetCacheTTL(24)

	scanner := NewScanner(config1, storage)

	// Verify initial TTL
	if scanner.cache.GetTTL() != 24*time.Hour {
		t.Errorf("Expected initial TTL 24h, got %v", scanner.cache.GetTTL())
	}

	// Update config
	config2 := DefaultConfig()
	config2.SetCacheTTL(48)

	scanner.SetConfig(config2)

	// Verify TTL was updated
	if scanner.cache.GetTTL() != 48*time.Hour {
		t.Errorf("Expected updated TTL 48h, got %v", scanner.cache.GetTTL())
	}
}

func TestScanner_CachePersistenceAcrossRestarts(t *testing.T) {
	storage := newMockStorage()
	config := DefaultConfig()
	config.SetCacheTTL(24)

	// First scanner instance - save scan
	scanner1 := NewScanner(config, storage)

	scan := &VulnerabilityScan{
		ImageID:   "sha256:abc123",
		ImageName: "nginx:latest",
		ScannedAt: time.Now(),
		Success:   true,
	}
	err := storage.SaveVulnerabilityScan(scan, []Vulnerability{})
	if err != nil {
		t.Fatalf("Failed to save scan: %v", err)
	}

	// Image should NOT need scanning
	if scanner1.NeedsScan("sha256:abc123") {
		t.Error("Expected NeedsScan to return false in first scanner")
	}

	// Simulate restart - create new scanner instance with same storage
	scanner2 := NewScanner(config, storage)

	// Image should still NOT need scanning (loaded from database)
	if scanner2.NeedsScan("sha256:abc123") {
		t.Error("Expected NeedsScan to return false after restart (should load from database)")
	}

	// Verify scan can be retrieved
	cached, err := scanner2.GetCachedScan("sha256:abc123")
	if err != nil {
		t.Fatalf("Failed to get cached scan after restart: %v", err)
	}

	if cached.ImageID != "sha256:abc123" {
		t.Errorf("Expected image ID sha256:abc123, got %s", cached.ImageID)
	}
}

func TestScanner_UpdateTrivyDB(t *testing.T) {
	storage := newMockStorage()
	config := DefaultConfig()

	scanner := NewScanner(config, storage)

	// This will fail in test environment without Trivy installed, but we're testing the interface
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err := scanner.UpdateTrivyDB(ctx)

	// We expect this to fail in test environment, but it shouldn't panic
	if err == nil {
		t.Log("UpdateTrivyDB succeeded (Trivy is installed)")
	} else {
		t.Logf("UpdateTrivyDB failed as expected in test environment: %v", err)
	}
}

func TestScanner_CacheTTLRespected(t *testing.T) {
	storage := newMockStorage()
	config := DefaultConfig()
	config.SetCacheTTL(1) // 1 hour TTL

	scanner := NewScanner(config, storage)

	// Save a scan that's 30 minutes old (within TTL)
	recentScan := &VulnerabilityScan{
		ImageID:   "sha256:recent",
		ImageName: "nginx:latest",
		ScannedAt: time.Now().Add(-30 * time.Minute),
		Success:   true,
	}
	err := storage.SaveVulnerabilityScan(recentScan, []Vulnerability{})
	if err != nil {
		t.Fatalf("Failed to save recent scan: %v", err)
	}

	// Should NOT need scanning (within 1-hour TTL)
	if scanner.NeedsScan("sha256:recent") {
		t.Error("Expected NeedsScan to return false for 30-minute-old scan with 1-hour TTL")
	}

	// Save a scan that's 90 minutes old (beyond TTL)
	oldScan := &VulnerabilityScan{
		ImageID:   "sha256:old",
		ImageName: "redis:latest",
		ScannedAt: time.Now().Add(-90 * time.Minute),
		Success:   true,
	}
	err = storage.SaveVulnerabilityScan(oldScan, []Vulnerability{})
	if err != nil {
		t.Fatalf("Failed to save old scan: %v", err)
	}

	// Should need scanning (beyond 1-hour TTL)
	if !scanner.NeedsScan("sha256:old") {
		t.Error("Expected NeedsScan to return true for 90-minute-old scan with 1-hour TTL")
	}
}

func TestScanner_MultipleImagesCaching(t *testing.T) {
	storage := newMockStorage()
	config := DefaultConfig()
	config.SetCacheTTL(24)

	scanner := NewScanner(config, storage)

	// Save scans for multiple images
	images := []string{"nginx:latest", "redis:latest", "postgres:latest"}
	for i, imageName := range images {
		scan := &VulnerabilityScan{
			ImageID:   fmt.Sprintf("sha256:image%d", i),
			ImageName: imageName,
			ScannedAt: time.Now(),
			Success:   true,
		}
		err := storage.SaveVulnerabilityScan(scan, []Vulnerability{})
		if err != nil {
			t.Fatalf("Failed to save scan for %s: %v", imageName, err)
		}
	}

	// All images should NOT need scanning
	for i := range images {
		imageID := fmt.Sprintf("sha256:image%d", i)
		if scanner.NeedsScan(imageID) {
			t.Errorf("Expected NeedsScan to return false for %s", imageID)
		}
	}

	// Invalidate one image
	scanner.InvalidateCache("sha256:image1")

	// Other images should still NOT need scanning
	if scanner.NeedsScan("sha256:image0") {
		t.Error("Expected sha256:image0 to still be cached")
	}
	if scanner.NeedsScan("sha256:image2") {
		t.Error("Expected sha256:image2 to still be cached")
	}
}
