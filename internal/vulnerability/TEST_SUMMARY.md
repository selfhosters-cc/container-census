# Vulnerability Scanning Test Coverage

This document summarizes the comprehensive test suite for the vulnerability scanning system, which validates that caching and stale result handling work correctly across application restarts.

## Test Files

1. **cache_test.go** - Cache behavior and TTL validation (10 tests)
2. **scanner_test.go** - Scanner integration with cache (9 tests)
3. **scheduler_test.go** - Worker pool and queue management (11 tests)

**Total: 30 tests, all passing**

## Key Scenarios Validated

### Cache Persistence Across Restarts ✅

**Test:** `TestScanner_CachePersistenceAcrossRestarts`

**What it validates:**
- Scanner instance #1 saves a scan to the database
- Scanner instance #2 (simulating restart) loads the same scan from database
- Image does NOT need rescanning after restart (cache check uses database)

**Why this matters:** This test proves that scan results persist across application restarts. When the server restarts, it doesn't blindly rescan all images - it checks the database and respects existing scan results within the TTL window.

### Fresh Scan Detection ✅

**Test:** `TestCache_NeedsScan_FreshScan`

**What it validates:**
- Scan completed less than 24 hours ago → `NeedsScan()` returns `false`
- Image is NOT queued for rescanning

**Why this matters:** Prevents unnecessary rescans of recently scanned images, reducing load and respecting rate limits.

### Stale Scan Detection ✅

**Tests:**
- `TestCache_NeedsScan_StaleScan`
- `TestScanner_CacheTTLRespected`

**What they validate:**
- Scan older than cache TTL (24 hours default) → `NeedsScan()` returns `true`
- Image IS queued for rescanning
- 30-minute-old scan with 1-hour TTL → NOT stale
- 90-minute-old scan with 1-hour TTL → IS stale

**Why this matters:** Ensures images are eventually rescanned for new vulnerabilities while respecting the configurable TTL.

### Database-Backed Cache ✅

**Tests:**
- `TestCache_Get_FromMemoryCache`
- `TestCache_Get_FromDatabaseAfterMemoryCacheExpiry`

**What they validate:**
- First retrieval → loads from database, populates memory cache
- Subsequent retrievals → uses fast memory cache
- Memory cache cleared → automatically reloads from database

**Why this matters:** Two-tier caching (memory + database) provides:
1. Fast access (memory cache)
2. Persistence across restarts (database)
3. Automatic fallback when memory cache is empty

### Queue Behavior ✅

**Test:** `TestScheduler_QueueScan_AlreadyScanned`

**What it validates:**
- Image with fresh scan is NOT added to queue
- Queue remains empty (no unnecessary work)

**Why this matters:** On startup, even though `queueImagesForScanning()` is called for all images, only images that actually need scanning are queued. This prevents the "scanning storm" you were experiencing.

### Cache Invalidation ✅

**Tests:**
- `TestCache_Invalidate`
- `TestScheduler_RescanAll`

**What they validate:**
- Manual "Rescan" button → invalidates cache
- `RescanAll()` → invalidates all images and queues them
- Invalidated images bypass TTL check and are rescanned

**Why this matters:** Users can force rescans when needed (e.g., after Trivy DB update).

### Concurrent Access ✅

**Test:** `TestCache_ConcurrentAccess`

**What it validates:**
- 10 goroutines simultaneously reading from cache
- No race conditions or panics
- Thread-safe via RWMutex

**Why this matters:** Multiple scan workers can safely check cache simultaneously.

## Critical Test: Restart Behavior

The most important test for your concern is `TestScanner_CachePersistenceAcrossRestarts`:

```go
func TestScanner_CachePersistenceAcrossRestarts(t *testing.T) {
    // First scanner instance - save scan
    scanner1 := NewScanner(config, storage)
    storage.SaveVulnerabilityScan(scan, []Vulnerability{})

    // Image should NOT need scanning
    if scanner1.NeedsScan("sha256:abc123") {
        t.Error("Expected NeedsScan to return false")
    }

    // Simulate restart - new scanner with same storage
    scanner2 := NewScanner(config, storage)

    // Image should STILL NOT need scanning (loaded from DB)
    if scanner2.NeedsScan("sha256:abc123") {
        t.Error("Expected NeedsScan to return false after restart")
    }
}
```

**Result:** ✅ PASS

## How the System Works

1. **On Startup:**
   - Scanner initializes with database connection
   - Memory cache is empty
   - `queueImagesForScanning()` called for all containers

2. **For Each Image:**
   - Calls `QueueScan(imageID, imageName, priority)`
   - `QueueScan()` checks `NeedsScan(imageID)` → calls cache
   - Cache checks memory → empty on startup
   - Cache checks database → finds scan from yesterday
   - Scan timestamp is < 24 hours old → returns valid
   - `NeedsScan()` returns `false` → NOT queued
   - Scan result is loaded into memory cache for future use

3. **Result:**
   - Only new images or stale scans (>24h) are queued
   - Existing fresh scans are silently skipped
   - No misleading log messages

## Test Execution

All 30 tests pass:

```bash
$ go test ./internal/vulnerability/...
ok  	github.com/container-census/container-census/internal/vulnerability	6.418s
```

## Coverage Areas

- ✅ Cache TTL enforcement
- ✅ Database persistence
- ✅ Memory cache behavior
- ✅ Restart simulation
- ✅ Queue management
- ✅ Worker pool dynamics
- ✅ Concurrent access safety
- ✅ Manual rescan triggering
- ✅ Cache invalidation
- ✅ Stale detection
- ✅ Fresh scan detection
- ✅ Multiple image tracking

## Conclusion

The test suite comprehensively validates that:

1. **Scans persist across restarts** via database storage
2. **Fresh scans are not repeated** (cache TTL respected)
3. **Stale scans are automatically requeued** (after 24 hours default)
4. **Manual rescans work** (cache invalidation)
5. **System is thread-safe** (concurrent access tested)

The caching system works exactly as intended - no unnecessary rescanning on startup.
